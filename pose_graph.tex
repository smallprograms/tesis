\section{Pose Graph Optimization}

When the amount of registered captures increment, the accumulated error 
becomes more visible. There is a drift respect to the real sensor trajectory. 
In order to afront this problem the most common approach is to use a pose graph 
optimization algorithm. 

Each pose of the sensor (rotation and translation) represents a node of the 
graph and each restriction between two poses represents an edge. The relative 
transformation between the two poses is used as restriction and it is possible 
to add different kinds of restrictions if more information is available.

Then we have the least squares minimization problem that can be described by the following equation:

$$ F(x) = \sum\limits_{<i,j> \in C } e(x_i,x_j,z_{ij})^T \Omega_{ij} e(x_i,x_j,z_{ij}) $$

$$ x^* = \mathop{\rm argmin}_x F(x) $$

Where $x=\{x_1,x_2,...,x_n\}$ and each $x_i$ represents a parameter block , $z_{i,j}$ and $\Omega_{ij}$ represents the mean  
 and the information matrix  of a constraint 
relating parameters $x_i$ and $x_j$.

Poses and relative transformations are represented by a 7x1 vector containing a traslation vector
 and a normalized quaternion for the rotation:

$$ \begin{bmatrix}
tx \\
ty \\
tz \\
qx \\
qy \\
qz \\
qw \\
\end{bmatrix}
$$

In our case $x_i$ corresponds to a sensor pose, $z_{ij}$ is the 
relative transformation between the pose i-esim and j-esim sensor capture, it is not affected by the accumulated error 
because it is a direct measure between the two captures and $\Omega_{ij}$ is the weight or 
the confidence we give to the restriction. $\Omega_{ij}$ is a 7x7 diagonal matrix, containg on its diagonal the confidence ($\in [0,1]$) for each 
parameter of the transformation. 

\begin{figure}[!h]
\begin{center}
\includegraphics[scale=1.5]{images/graph_diagram2}
\caption{Graph of poses $(x_1,x_2,..)$ with constraints $(z_{12},z_{23},...)$ relating poses}
\end{center}
\end{figure}

This is a non linear least squares problem and can be solved using 
methods such as for example Gauss-Newton or Levenberg-Marquardt.


Then $e_{ij}$ is an error vector (7x1) defined as follows:

$$
e(x_i,x_j,z_{ij}) = z_{ij} - \hat{z_{ij}}
$$

Where $\hat{z_{ij}}$ is the relative transformation between $x_i$ and $x_j$ obtained directly from the pose graph, for this reason 
it is affected by the accumulated error.

We want to find a graph configuration (updating the poses $x=\{x_1,x_2,...,x_n\}$), in order to reduce 
the global error, correcting some poses in order to satisfy the restrictions.

To simplify notation let: 

$$
e(x_i,x_j,z_{ij}) = e(x_i,x_j) = e_{ij}(x)
$$

We can approximate the previous function around one point:

\begin{equation}
\label{eq:errorAprox}
e_{ij}(x + \Delta x) \simeq e_{ij}(x) + J_{ij} \Delta x
\end{equation}

$J_{ij}$ is the Jacobian of the function evaluated in x. 


\begin{equation}
\label{eq:globalFunc}
F_{ij}(x + \Delta x) = e_{ij}(x + \Delta x)^T \Omega_{ij}  e_{ij}(x + \Delta x)
\end{equation}

Reeplacing \ref{eq:errorAprox} in the global function:

\begin{equation}
\label{eq:globalFuncAprox}
F_{ij}(x + \Delta x) \simeq (e_{ij}(x) + J_{ij} \Delta x)^T \Omega_{ij}  (e_{ij}(x) + J_{ij} \Delta x)
\end{equation}

\begin{equation}
\label{eq:globalFuncAprox2}
 =  \underbrace{e_{ij}(x)^T \Omega_{ij} e_{ij}(x)}_{c_{ij}} + 2  \underbrace{e_{ij}(x)^T \Omega_{ij} J_{ij}}_{b_{ij}} \Delta x + \Delta x^T \underbrace{ J_{ij}^T  \Omega_{ij} J_{ij}}_{H_{ij}} \Delta x
\end{equation}

\begin{equation}
\label{eq:globalFuncAprox2}
 = c_{ij} + 2 b_{ij} \Delta x + \Delta x^T H_{ij} \Delta x
\end{equation}


\begin{equation}
F(x + \Delta x) =  \sum\limits_{<i,j> \in C } F_{ij}(x + \Delta x) 
\end{equation}



\begin{equation}
\simeq  c_{ij} + 2 b_{ij} \Delta x + \Delta x^T H_{ij} \Delta x
\end{equation}

\begin{equation}
=   c + 2 b \Delta x + \Delta x^T H \Delta x
\end{equation}

Where $c=\sum{c_{ij}}, b=\sum{b_{ij}}$ and $H=\sum{H_{ij}}$.

Then we want to know $\Delta x^T$, this is the correction to nodes of the graph in order 
to have a minimum error:

\begin{equation}
H \Delta x^* = -b
\end{equation}

Having $\Delta x^T$ we can update the graph nodes:

\begin{equation}
x^* = x + \Delta x^* 
\end{equation}

This is the Gauss-Newton algorithm. 

The Levenber-Marquardt (LM) is a nonlinear variant of the Gauss-Newton algorithm that introduces a
damping factor and backup actions to control the convergence:

\begin{equation}
(H + \lambda I) \Delta x^* = -b
\end{equation}

The $\lambda$ factor controls the size of $ \Delta x$. Allowing changing it according to the error between the iterations.
 
The approach asumes that the spaces of parameters $x$ is Euclidean. However, this is not the case for the quaternion, 
in consequence it is necessary to apply he concept of Manifold.



G2o is a library that contains non linear error functions optimization 
algorithms for graphs and is widely used in registration algorithms. 

The poses where optimized using this library and specifically the 
Levenber-Marquardt algorithm.

This correction of the poses allows spreading error among the different nodes and reduce drift. The result 
will depend on the quality of the graph.

\subsection{Least Squares on Manifold}

A Manifold is a topology space that is locally Euclidean. In other words each point has a neighbourhood that is 
homeomorphic to the Euclidean space. The Manifold is not necessarily Euclidean on a global space, but can be seen 
as Euclidean in a local scale \cite{manifold}.

The translation component of the parameters vector forms a euclidean space, but the rotation component does not.
In order to afront this problem the error minimization is applied on a Manifold. The rotation is represented as a 
quaternion to avoid the singularities of use euler angles (Gimbal Lock), but using a quaternion we have one extra 
dimension. Because a 3D rotation can be represented with three numbers and a quaternion has four. Applying the 
minimization directly over the quaternions lead to errors...

An alternative idea is to consider the underlying space as a manifold
and to define an operator $\boxplus$ that maps a local variation
$\Delta x$ in the Euclidean space to a variation on the manifold, $\Delta x \mapsto x + \Delta x$. 
Mathematical details can be found in \cite{hertzberg08}. The local variation is enconded using a minimal 
representation, the axis part of the quaternion $(q_i,q_j,q_k)$. The operator $\boxplus$ converts the 
resulting transformation to a full quaternion.

In order to define this operator, first Lets define a composition operator $\oplus$:

$$
x_i \oplus x_j = \begin{bmatrix} t_i + q_i(t_j) \\ q_i \cdot q_j \end{bmatrix}
$$

Where $q_i(t_j)$ is the vector resulting from applying rotation represented by $q_i$ to vector $t_j$ and 
$q_i \cdot q_j$ is the standard quaternion multiplication.

Then the operator $\boxplus$ is defined as follows:

$$
x_i \boxplus \Delta x_i = x_i \oplus \begin{bmatrix} \Delta t_i \\ \Delta q_i \\ \sqrt{1-||\Delta q_i||}  \end{bmatrix}
$$

Note that $\Delta q_i$ contains only axis part of the quaternion.

Using this operator a new error function can be defined:

$$
\hat{e}_{ij}(\Delta x_i,\Delta x_j) = e(x_i \boxplus \Delta x_i,x_j \boxplus \Delta x_j)
$$

$$
= e_{ij}(x \boxplus \Delta x) \approx e_{ij} + \hat{J}_{ij} \Delta x
$$

Where the Jacobian $\hat{J}_{ij}$ can be expressed as:

$$
\hat{J}_{ij} = \frac{\partial{e_{ij}(x \boxplus \Delta x)}}{\partial{\Delta x}} \bigg|_{\Delta x=0}
$$

\subsection{Loop Closure}

When the sensor vists the same region at different times, for example following 
a circular trajectory. A restriction between two non-consecutive captures can be 
added to the graph. In the case of a circular trajectory, the accumulated error 
is very noticeable when the initial and the final capture are connected. When a  
restriction between this two captures is added to the graph it is possible to 
adjust the position of all poses in order to reduce the accumulated error. Loop Closure is 
a restriction between two non-consecutive poses.


\begin{figure}[!h]
\begin{center}
\includegraphics[scale=0.35]{images/drift}
\caption{Example of drift from real trajectory. Blue color: real camera trajectory, red color: estimation of trajectory with accumulated error.}
\end{center}
\end{figure}

\begin{figure}[!h]
\begin{center}
\includegraphics[scale=0.65]{images/loop_detection}
\caption{Example of loop closure constraint}
\end{center}
\end{figure}

\subsubsection{Loop Detection}

In order to add loop closure constraints it is necessary to detect areas of the scene 
 that where previously visited. For this, images that have close euclidean distance between 
their corresponding poses.

In order to detect previously visited areas of the scene SURF \cite{Bay06surf} feature detector 
is used. SURF keypoints are calculated and then the descriptors for each keypoint are obtained for 
each image.

 Then  the images are compared, using the difference between SURF descriptors.   

